%{
  from gyb_utils import (
    autogenerated_warning, requestBodyProtocols, responseBodyProtocols)
}%
${autogenerated_warning()}

import Foundation

extension Networking {

  @inlinable
  @discardableResult
  public func executeRaw<E>(_ endpoint: E, completion: @escaping (RawResult) -> Void) throws -> Task where E: Endpoint {
    execute(try request(endpoint), completion: completion)
  }

  % for requestBodyProtocol in requestBodyProtocols:
  @inlinable
  @discardableResult
  public func executeRaw<E>(_ endpoint: E, completion: @escaping (RawResult) -> Void) throws -> Task where E: Endpoint, E.RequestBody: ${requestBodyProtocol} {
    execute(try request(endpoint), completion: completion)
  }
  
  % for responseBodyProtocol in responseBodyProtocols:
  @inlinable
  @discardableResult
  public func execute<E>(_ endpoint: E, completion: @escaping (EndpointResult<E>) -> Void) throws -> Task where E: Endpoint, E.RequestBody: ${requestBodyProtocol}, E.ResponseBody: ${responseBodyProtocol} {
    try executeRaw(endpoint) { result in
      switch result {
      case .success(let rawResponse):
        do {
          try endpoint.validate(networking: self, response: rawResponse)
          completion(.success((
            rawResponse.response,
            % if responseBodyProtocol == "CustomResponseBody":
            .init(catching: { try self.decode(body: rawResponse.body) })
            % else:
            .init(catching: { try self.decode(contentType: endpoint.acceptType, body: rawResponse.body) })
            % end
          )))
        } catch {
          completion(.failure(error))
        }
      case .failure(let error):
        completion(.failure(error))
      }
    }
  }

  % end
  % end
  % for responseBodyProtocol in responseBodyProtocols:
  @inlinable
  @discardableResult
  public func execute<E>(_ endpoint: E, completion: @escaping (EndpointResult<E>) -> Void) throws -> Task where E: Endpoint, E.ResponseBody: ${responseBodyProtocol} {
    try executeRaw(endpoint) { result in
      switch result {
      case .success(let rawResponse):
        do {
          try endpoint.validate(networking: self, response: rawResponse)
          completion(.success((
            rawResponse.response,
            % if responseBodyProtocol == "CustomResponseBody":
            .init(catching: { try self.decode(body: rawResponse.body) })
            % else:
            .init(catching: { try self.decode(contentType: endpoint.acceptType, body: rawResponse.body) })
            % end
          )))
        } catch {
          completion(.failure(error))
        }
      case .failure(let error):
        completion(.failure(error))
      }
    }
  }

  % end
}
