%{
  from gyb_utils import (
    autogenerated_warning, requestBodyProtocols, responseBodyProtocols)
}%
${autogenerated_warning()}

import Foundation
import NIO

extension EventLoopFutureNetworking {

  @inlinable
  public func eventLoopFutureRaw<E>(_ endpoint: E) -> EventLoopFuture<RawResponse> where E: Endpoint {
    do {
      return eventLoopFuture(try request(endpoint))
    } catch {
      return eventLoop.makeFailedFuture(error)
    }
  }

  % for requestBodyProtocol in requestBodyProtocols:
  @inlinable
  public func eventLoopFutureRaw<E>(_ endpoint: E) -> EventLoopFuture<RawResponse> where E: Endpoint, E.RequestBody: ${requestBodyProtocol} {
    do {
      return eventLoopFuture(try request(endpoint))
    } catch {
      return eventLoop.makeFailedFuture(error)
    }
  }

  % for responseBodyProtocol in responseBodyProtocols:
  @inlinable
  public func eventLoopFuture<E>(_ endpoint: E) -> EventLoopFuture<EndpointResponse<E>> where E: Endpoint, E.RequestBody: ${requestBodyProtocol}, E.ResponseBody: ${responseBodyProtocol} {
    eventLoopFutureRaw(endpoint)
      .flatMapThrowing { rawResponse -> RawResponse in
        try endpoint.validate(networking: self, response: rawResponse)
        return rawResponse
      }
      .map { rawResponse in
        (response: rawResponse.response, body: .init { try self.decode(endpoint, body: rawResponse.body) })
      }
  }

  % end
  % end
  % for responseBodyProtocol in responseBodyProtocols:
  @inlinable
  public func eventLoopFuture<E>(_ endpoint: E) -> EventLoopFuture<EndpointResponse<E>> where E: Endpoint, E.ResponseBody: ${responseBodyProtocol} {
    eventLoopFutureRaw(endpoint)
      .flatMapThrowing { rawResponse -> RawResponse in
        try endpoint.validate(networking: self, response: rawResponse)
        return rawResponse
      }
      .map { rawResponse in
        (response: rawResponse.response, body: .init { try self.decode(endpoint, body: rawResponse.body) })
      }
  }
  
  % end
}
