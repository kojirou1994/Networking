
// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################


import Foundation
import NIO
import NIOFoundationCompat

// MARK:  Default implementation for decoding
extension Networking where RawResponseBody == Data {

  @inlinable
  public func decode<ResponseBody>(contentType: ContentType, body: RawResponseBody) -> Result<ResponseBody, NetworkingError> where ResponseBody: Decodable {
    #if NETWORKING_LOGGING
    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
      let bodyString = String(decoding: body, as: UTF8.self)
      logger.debug("Decoding Response Body: \(bodyString)")
    }
    #endif
    switch contentType {
    case .json:
      do {
        return try .success(jsonDecoder.decode(ResponseBody.self, from: body))
      } catch {
        return .failure(.decode(error))
      }
    case .none: fatalError("Should never be called")
    case .wwwFormUrlEncoded:
      fatalError("Unsupported")
    }
  }

  @inlinable
  public func decode<ResponseBody>(body: RawResponseBody) -> Result<ResponseBody, NetworkingError> where ResponseBody: CustomResponseBody {
    do {
      return try .success(.init(body))
    } catch {
      return .failure(.decode(error))
    }
  }

}
// MARK:  Default implementation for decoding
extension Networking where RawResponseBody == ByteBuffer {

  @inlinable
  public func decode<ResponseBody>(contentType: ContentType, body: RawResponseBody) -> Result<ResponseBody, NetworkingError> where ResponseBody: Decodable {
    #if NETWORKING_LOGGING
    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
      let bodyString = body.getString(at: body.readerIndex, length: body.readableBytes) ?? ""
      logger.debug("Decoding Response Body: \(bodyString)")
    }
    #endif
    switch contentType {
    case .json:
      do {
        return try .success(jsonDecoder.decode(ResponseBody.self, from: body))
      } catch {
        return .failure(.decode(error))
      }
    case .none: fatalError("Should never be called")
    case .wwwFormUrlEncoded:
      fatalError("Unsupported")
    }
  }

  @inlinable
  public func decode<ResponseBody>(body: RawResponseBody) -> Result<ResponseBody, NetworkingError> where ResponseBody: CustomResponseBody {
    do {
      return try .success(.init(body.readableBytesView))
    } catch {
      return .failure(.decode(error))
    }
  }

}
// MARK:  Default implementation for decoding
extension Networking where RawResponseBody == ByteBufferView {

  @inlinable
  public func decode<ResponseBody>(contentType: ContentType, body: RawResponseBody) -> Result<ResponseBody, NetworkingError> where ResponseBody: Decodable {
    #if NETWORKING_LOGGING
    if #available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) {
      let bodyString = String(decoding: body, as: UTF8.self)
      logger.debug("Decoding Response Body: \(bodyString)")
    }
    #endif
    switch contentType {
    case .json:
      do {
        return try .success(jsonDecoder.decode(ResponseBody.self, from: Data(body)))
      } catch {
        return .failure(.decode(error))
      }
    case .none: fatalError("Should never be called")
    case .wwwFormUrlEncoded:
      fatalError("Unsupported")
    }
  }

  @inlinable
  public func decode<ResponseBody>(body: RawResponseBody)-> Result<ResponseBody, NetworkingError> where ResponseBody: CustomResponseBody {
    do {
      return try .success(.init(body))
    } catch {
      return .failure(.decode(error))
    }
  }

}
